# Here's a handcrafted CVE entry that I had in mind
# I put URLs in the comments so you can look them up easily
# -Andy
CVE: CVE-2011-3092
CWE: 119
announced: 2012-05-15
description_instructions:
  These descriptions are taken from the National Vulnerability Database, and can be kind of jargony. Rewrite this in your own words to be easier to read. We can always pull up the NVD description later. Please remove references to versions, specific filenames, and other jargon that outsiders to Chromium would not understand.
description:
  The regex implementation in Google's Javascript engine *V8* allows remote attackers to cause an invalid write operation to memory. This could cause a denial of service, or possibly have unspecified other impact via unknown vectors.
bounty:
  amt: 1000.00
  announced: 2012-05-15
  url: http://googlechromereleases.blogspot.com/2012/05/stable-channel-update.html
reviews:
  - 10008104
bugs:
  - 122337
repo: https://chromium.googlesource.com/v8/v8/
fixes:
   - commit: b32ff09a49fe4c76827e717f911e5a0066bdad4b
     note:
vccs:
  - commit: 0adfe842a515dd206cb0322d17c05f97244c0e72
    note: They were working on a fix for something else at the time.
  - commit: 498b074bd0db2913cf2c9458407c0d340bbcc05e
    note: They were working on a fix for something else at the time.
upvotes: 1000

unit_tested:
  question:
    Were automated unit tests involved in this vulnerability?
    More specifically, was the original code unit tested, or not unit tested? (code).

    For the "code" answer below, look not only at the fix but the surrounding code near the fix and determine if
    and was there were unit tests involved for this module.

    For the "fix" answer below, check if the fix for the vulnerability involves adding or improving an automated test to ensure this doesn't happen again.
  code: true
  fix:  true
  unclear: # Place any reasons for which you believe the data is unclear on this point. here

discovered:
  question:
    How was this vulnerability discovered? Go to the bug report and
    read the conversation to find out how this was originally found. Answer in
    longform below, fill in the date, and then determine if the vulnerability was
    found by a Google employee (you can tell from their email address).
  answer: Found using LangFuzz, then reproduced by hand. Nobody was able to construct an exploit, but they were also not comfortable stating that an exploit was impossible.
  date: 2012-04-11
  automated: true
  google: true
  contest: # put the name, or leave empty if not

subsystem:
  question:
    What subsystems was the mistake in? Look at the path of the source
    code files code that were fixed to get directory names. Look at comments in
    the code. Look at the bug reports how the bug report was tagged.
  answer: Based on the description in the CVE and blog post.
  name: v8

interesting_commits:
  question:
    Are there any interesting commits between your VCC(s) and fix(es)? Write a brief (under 100 words) description of why you think this commit was interesting in light of the lessons learned from this vulnerability. Any emerging themes?
  commits:
    - commit: 1729e3c0ddf0c7a0f912ef38355d38afe284bf04
      note:
        They worked on changing the responsibilities between the Javascript side and the native side. This is pertinent because that seemed to be the source of the breakdown of our vulnerability in that the Javascript assumed the native code had more checks than it did. Following up and reading the code review, they reference "offline" discussions - so this is probably mostly a co-located team within Google.
    - commit: 0f682143d9a50441188ae09cbd669f5389e44597
      note:
        They worked with some memory management issues on the native code in this commit. No code review for this change, but it was a very large change on the native side, with some changes on the Javascript side.
    - commit: e1458503d13cbcc20ae619a1a4d6d0be9cb74bfb
      note:
        Tons of code removed for this commit, related to how caching works. No rationale was obvious from the documents, but it was a very significant change code-wise.

major_events:
  question:
    Please record any major events you found in the history of this vulnerability. Was the code rewritten at some point? Was a nearby subsystem changed? Did the team change? The event doesn't need to be directly related to this vulnerability, rather, we want to capture what the development team was dealing with at the time.
  answer: I did not see any major events during this time.
  events:
    - event: # don't put anything here
        name: ~ # Describe in under 50 chars
        date: ~ # YYYY-MM-DD
    - event: # don't put anything here
        name: ~ # Describe in under 50 chars
        date: ~ # YYYY-MM-DD
        # ... add more if you found more events

linguistics:
  question:
    Examine the discussions between the VCC and the fix. Look at the code reviews, the bug reports, and any other discussion you happen to come across.

    Look for how they use the English language.
    Politeness - are people thanking each other? Expressing appreciation? Asking
      nicely? Or is it more terse?
    Rudeness - did you see a conversation get heated or opinionated?
    Questioning - is feedback being given in the form of a question? Are
      developers questioned about the decisions they made?
  # Provide a thoughtful, interesting response. 50-100 word.
  answer:
    I only found politeness in my code reviews. I did not see questioning or rudeness. Most of my team was co-located, so most of that kind of language would not be capture in code reviews.
  polite:
    # Provide a link to an example if you find one
    url: https://codereview.chromium.org/4308001
    description: "Good point"
  rude:   # true, false, or just leave blank
    url: # Provide a link to an example if you find one
    description: # Explain briefly
  questioning:
    url: # Provide a link to an example if you find one
    description: # Explain briefly

lessons:
  question:
    Are there any common lessons we have learned from class that apply to this vulnerability? In other words, could this vulnerability serve as an example of one of those lessons?

    Leave it blank or put false if you did not see that lesson (you do not need to put a reason). Put "true" if you feel the lesson applies and put a quick explanation of how it applies.
  defense_in_depth:
    applies:
    note:
  least_privilege:
    applies:
    note:
  frameworks_are_optional:
    applies:
    note:
  native_wrappers:
    applies: true
    note:
      The vulnerability was largely about the interaction between native C code that implemented string functions, and the high-level API of Javascript. The fix was still in Javascript even though it was a memory corruption error.
  distrust_input:
    applies:
    note:
  security_by_obscurity:
    applies:
    note:
  serial_killer:
    applies:
    note:
  environment_variables:
    applies:
    note:
  secure_by_default:
    applies:
    note:
  yagni:
    applies:
    note:
  complex_inputs:
    applies: true
    note:
      The vulnerability involved the parsing of a regular expression, which is a very complex language.

mistakes:
  question:
    In your opinion, after all of this research, what mistakes were made
    that led to this vulnerability? Coding mistakes? Design mistakes?
    Maintainability? Requirements? Miscommunications?

    Look at the CWE entry for this vulnerability and examine the mitigations they
    have written there. Are they doing those? Does the fix look proper?

    Use those questions to inspire your answer. Don't feel obligated to answer
    every one. Write a thoughtful entry here that those ing the software
    engineering industry would find interesting.
  answer:
    The coding mistake that was made was essentially an integer overflow that led to miscalculating memory buffers. The mistake was not in the underlying native code, rather, it was misusing the C API. So the fix was actually in the Javascript implementation of regexp.

    The vulnerability was introduced over two commits, but reall by one person who was working on trying to fix this boundary condition. They weren't working on a vulnerability per se, but they were working on a boundary condition and still missed this one condition.

    Over time, a lot of decisions have been made about changing what is handled natively and what is handled in Javascript itself. Navigating what exactly are the responsibilities of native code versus the built-in Javascript libraries is going to be the key to preventing vulnerabilities here.
